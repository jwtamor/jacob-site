<!DOCTYPE html>
<html>
    <head>
        <title>Projects</title>
        <link rel="stylesheet" href="style.css">
        <link href='https://fonts.googleapis.com/css?family=Roboto Mono'
            rel='stylesheet'>
    </head>
    <body>
        <nav class="navbar">
            <ul>
                <li><a href="../projects.html">Back</a></li>
            </ul>
        </nav>
        <div class="project_heading">
            <h1>RPi DJ</h1>
            <div class="row">
                <iframe width="640" height="360"
                    src="https://www.youtube.com/embed/pHU6sa2pq2I"
                    frameborder="0" allowfullscreen class="cover"></iframe>
                <p>
                    This application was developed for the course ECE 5725:
                    Design with Embedded Operating Systems. The objectives
                    of the project were to synthesize clear audio playback
                    using Python to process the digital audio in the
                    Raspberry Pi. In addition, there would be an intuitive
                    user interface to display on the piTFT to control the
                    audio playback and dynamically adjust the audio.
                </p>
            </div>
        </div>
        <main>
            <p>
                This drawing below shows the schematic for the main and
                peripheral hardware:
            </p>
            <img src="Images/rpi_dj_sch.png">
            <p>
                As shown, the Raspberry Pi communicates with the external
                Digital to Analog Converter chip, so all the audio processing
                occurs in the digital domain. The DAC directly outputs to
                an audio jack connector, which then is connected to a set of
                speakers.
            </p>
            <p>
                Because the ultimate goal of this project is to manipulate
                the audio to hear different frequency ranges at different
                volumes, much of the audio processing occurs in the
                frequency domain. The .wav files, however, that are loaded
                into the Python program, hold their information in the time
                domain, so the audio processing first applies an FFT on a
                fixed number of samples, manipulates the audio in the
                frequency domain, then applies an inverse FFT to achieve
                back the audio in the time domain so that it can be
                outputted to the DAC. The audio is processed in accordance with
                the GUI in the piTFT that chooses the amplitudes of each
                frequency bucket.
            </p>
            <img src="Images/playback_screen.jpg" class="small_img">
            <p>
                The GUI shown above is composed of bards that represent
                the master volume and the volumes that correspond to the
                specific frequency ranges to be controlled. The buttons on
                either side of the bars will increase or decrease the volumes
                indicated, and the point on the bar will shift corresponding to
                that button press. The thread that runs the GUI and the thread
                that processes and outputs the audio run in independent threads
                such that the time requirements of the audio output is met and
                the sound can be cohesive at the correct frequency. The GUI
                communicates its information to the processing thread in order
                to provide the sound level scalars required in the audio
                processing.
            </p>
            <p>
                Through this project, I gained experience in implementing simple
                mechanisms in audio processing using Python. I also learned
                different ways the numpy module can be used to acheive a variety
                of mathematical computations. Additionally, becuaes of the
                timing requirements with resepct to the frequency of the audio,
                I was able to practice code optimization and discover different
                ways in which the language can be leveraged in order to acheive
                faster code.
            </p>
            <p>
                For an in-depth report on this project, please visit the <a
                    href="https://courses.ece.cornell.edu/ece5990/ECE5725_Spring2023_Projects/2%20Friday%20May%2012/4%20RPi%20DJ/M_jwt95_rjw252/M_jwt95_rjw252/index.html"
                    target="_blank">
                    project page</a> on Joe Skovira's ECE 5725 course website!
            </p>
        </main>
    </body>
</html>
